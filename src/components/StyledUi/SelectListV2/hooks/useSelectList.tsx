import React, {
  createContext,
  useContext,
  useState,
  ReactNode,
  useEffect,
  useCallback
} from 'react';
import { SelectListGroupItemProps } from '../SelectList.types';
import { getSelectedGroups } from '../helpers/selectListDataHelpers';
/**************************************************************************
/* This is a custom hook useSelectList that returns
/* aray - the select list selected object and the handler. */
/* example const [ selected, handleSelectList] = useSelectList(data, [groupKey], [idKey])
/*
/* selected is an object that contains selected items from
/*  a list. The object is structured in a way that groups
/*  items by a common key and has an inner object that
/*  represents each item and whether it's selected or not. 
/*
/* handle is a function that takes a type, groupKey, and
/*  itemKey as arguments. It handles the selection/deselection
/*  of items and groups based on the type provided. */
/*
/* ---------------------------------------------------------------------
/*
/* This hook uses useState to initialize the selected state
/*  to an object generated by the generateSelectListItems function.
/*  This function takes an array of data and two keys (groupKey
/*  and itemKey) to group the data by the groupKey and select
/*  each item with the itemKey.
/*
/* The toggleItem function takes a groupKey and itemKey and
/*  toggles the selection of the item with that key in the selected
/*  state. The hasAllSelected function checks whether all items
/*  are selected, either across all groups or for a specific
/*  group (groupId). The selectNone function deselects all items. 
/*
/* The toggleGroup function toggles the selection of all items
/*  in a group (groupId). Finally, the handle function is a switch
/*  statement that takes a type argument and handles the selection/deselection
/*  of items and groups based on the type provided. 
/*
/* Overall, this hook provides a simple way to manage the selection
/*  state of a list of items grouped by a common key. 
/*
/* The return selected object looks something like this:
/* selected = {
/*  chicken: {
/*    fried: true,
/*    baked: true,
/*    raw: false
/*  }, 
/*  fish: {
/*    fried: false,
/*    baked: true,
/*    raw: true
/*  }
/* }
/*
**************************************************************************/
export interface UseGroupSelectListProviderProps {
  children?: ReactNode | ReactNode[];
  items?: SelectListGroupItemProps;
  returnEmpty?: boolean;
  refresh?: unknown;
}

export const UseGroupSelectListProvider = ({
  children,
  items,
  returnEmpty,
  refresh
}: UseGroupSelectListProviderProps): JSX.Element => {
  if (!items && returnEmpty) return <div></div>;

  const [selected, setSelected] = useState<SelectListGroupItemProps[] | undefined>(
    items ? [items] : undefined
  );
  const [current, setCurrent] = useState(0);

  let hasUndo = false;
  let hasRedo = false;
  let hasClear = false;

  if (selected) {
    const count = selected.length;
    hasUndo = current < count - 1 && count > 1;
    hasRedo = current > 0 && current < count;
    hasClear = hasUndo || hasRedo ? true : false;
  }

  const currentlySelected = selected?.[current];

  useEffect(() => {
    if (items) {
      if (!selected) return setSelected(items ? [items] : []);
      else {
        const start = JSON.stringify(selected[selected.length - 1]);
        const cur = JSON.stringify(items);

        if (start !== cur) setSelected([items]);
      }
    }
  }, [items, refresh]);

  const handle = useCallback(
    (type: string, groupId?: string, itemId?: string) => {
      switch (type) {
        case 'toggleItem': {
          if (!groupId || !itemId || !selected) {
            Error('missing groupId or itemId in handler');
            return false;
          }
          const newSel = JSON.parse(JSON.stringify(selected?.[current]));

          // if it's the first click, only select the clicked item
          if (selected?.length == 1 && current == 0) {
            Object.entries(newSel).map(([gid, items]) =>
              Object.keys(items as Record<string, boolean>).map((itemId) => {
                newSel[gid][itemId] = false;
              })
            );
          }

          newSel[groupId][itemId] = !newSel[groupId][itemId];

          const selectedGroups = getSelectedGroups(newSel);

          if (!selectedGroups.length && items) return setSelected([items]);

          return [setSelected([newSel, ...selected]), setCurrent(0)];
        }

        case 'toggleGroup': {
          if (!groupId || !selected || !items) {
            Error('missing groupId or itemId in handler');
            return false;
          }

          const newSel = JSON.parse(JSON.stringify(selected?.[current]));

          // if it's the first click, only select the clicked group
          if (selected?.length == 1 && current == 0) {
            Object.entries(newSel).map(([gid, items]) =>
              Object.keys(items as Record<string, boolean>).map((itemId) => {
                if (gid === groupId) newSel[gid][itemId] = true;
                else newSel[gid][itemId] = false;
              })
            );
            return setSelected([newSel, ...selected]);
          }

          const hasSelected = getSelectedGroups(newSel).includes(groupId);

          Object.keys(newSel[groupId]).map((id) => (newSel[groupId][id] = !hasSelected));

          // check if the last slice was just clicked
          if (getSelectedGroups(newSel).length == 0) return setSelected([items]);

          return [setSelected([newSel, ...selected]), setCurrent(0)];
        }

        case 'selectGroupAll': {
          if (!groupId || !selected) {
            Error('missing groupId or itemId in handler');
            return false;
          }
          const newSel = JSON.parse(JSON.stringify(selected?.[current]));
          Object.keys(newSel[groupId]).map((id) => (newSel[groupId][id] = true));
          return setSelected([newSel, ...selected]);
        }

        case 'selectGroupNone': {
          if (!groupId || !selected) {
            Error('missing groupId or itemId in handler');
            return false;
          }
          const newSel = JSON.parse(JSON.stringify(selected?.[current]));
          Object.keys(newSel[groupId]).map((id) => (newSel[groupId][id] = false));
          return setSelected([newSel, ...selected]);
        }

        case 'undo': {
          if (!selected) {
            Error('error in select list click handler');
            return false;
          }
          return setCurrent(current + 1);
        }

        case 'redo': {
          if (!selected) {
            Error('error in select list click handler');
            return false;
          }
          return setCurrent(current - 1);
        }

        case 'clear': {
          if (!selected || !items) {
            Error('error in select list click handler');
            return false;
          }
          return [setSelected([items]), setCurrent(0)];
        }

        default:
          return false;
      }
    },
    [selected, current, items]
  );

  const setAll = (data?: SelectListGroupItemProps) =>
    !selected ? false : data ? setSelected([data, ...selected]) : handle('clear');

  const isLoading = !selected || !items;

  return (
    <UseGroupSelectListContext.Provider
      value={{
        selected: currentlySelected,
        handle,
        hasUndo,
        hasRedo,
        hasClear,
        setSelected: setAll
      }}
    >
      {!isLoading && children}
    </UseGroupSelectListContext.Provider>
  );
};

export type UseGroupSelectListContextProps = {
  selected?: SelectListGroupItemProps;
  handle?: (type: string, groupId?: string, itemId?: string) => void;
  setSelected?: (selected?: SelectListGroupItemProps) => void;
  hasUndo?: boolean;
  hasRedo?: boolean;
  hasClear?: boolean;
};

export const UseGroupSelectListContext = createContext<UseGroupSelectListContextProps>({});
export const useGroupSelectList = (): UseGroupSelectListContextProps =>
  useContext(UseGroupSelectListContext);
